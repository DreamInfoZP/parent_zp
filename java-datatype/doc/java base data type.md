

### java数据类型

#### 基本数据类型

* 整数型	byte short int long
* 浮点型    float double
* 字符型    char
* 布尔型    boolean

#### 引用数据类型

​	字符串、数组、类、接口、Lamdba

#### 注意事项

1. 浮点数当中默认类型时double，如果一定要使用float类型，需要加上一个后缀F

2. 如果是整数，默认为int类型，如果一定要使用float类型，需要加上一个后缀L

3. 强制类型转换一般不推荐使用，可能发生进度损失、数据溢出

4. byte/short/char着三种类型都可能发生数字运算，例如加法“+”

5. byte/short/char这三种类型在运算的时候，都会被首先提升为int类型，然后再计算

6. 48-'0'   65-'A'   97-'a'

7. 对于byte、short、char三种类型来说，如果右侧赋值的数值没有超过范围，那么对于javac编译器将会自动隐含地为我们补上一个(byte)(short)(char)

   ```java
   byte num1 = 30 ; 
   // 右侧确实是一个int数字，但是没有超过左侧的范围，完整的语句是
   byte num1 = (byte) 30;
   ```

   

#### 运算符注意事项

1. ++，--
   * 单独使用：不和其他操作混合，自己独立成为一个步骤
   * 呼和使用：和其他操作混合使用，赋值操作，打印操作混合
2. 使用区别
   * 在单独使用的时候，前++和后++没有任何区别
   * 在混合使用
     * 如果是【前++】，那么变量【立刻马上+1】，然后拿着结果进行使用
     * 如果是【后++】，那么变量使用本来的值，【然后再让变量+1】

#### 逻辑运算符

1. &&和&与||和|区别

   A&&B, 当A为false时，不去计算B的值而直接返回false；当A为true时，计算B的值。

   * &&和&都是表示与，区别是&&若第一个条件不满足，后面条件就不再判断。而&要对所有的条件都进行判断

   a||b：只有a与b都为false，结果才为false；有一个为true，结果为true。

   * || 和 | 都是表示与，区别是 || 若第一个条件不满足，后面条件就不再判断。而 | 要对所有的条件都进行判断

#### 三元运算符

1. 格式
   * 数据类型	变量名称	=	条件判断	？	表达式A	：	表达式B;



#### JShell小工具

1. JDK9有的特性
2. 执行执行命令语句不需要繁琐的固定格式



#### 编译器优化

1. 编译器常量优化
   * 如果右侧表达式中全部都是常量，没有任何变量编译器会直接将常量计算结果编译到字节码文件中
   * 一旦表达式中有变量参与，那么就不能进行这种优化了

#### 选择语句

1. switch
   * case中一旦有对应的值，就会执行相应的语句，在执行过程中，遇到break就会结束，否则会一直执行下去
   * default当case中没有匹配语句执行default逻辑

#### 循环语句

1. for、while、do-while
2. 三种循环的区别
   * 如果条件从来没有满足过，那么for和while循环将会执行0次，但是do-while循环至少执行一次
   * 作用域不同【for循环的变量在小括号中定义，只有循环内部才可以使用。while循环和do-while寻栓初始化语句本来就在外面，所以循环完成以后可以继续使用】

#### Java内存划分

1. 栈(Stack)：存放的都是方法的局部变量，方法运行一定是在栈中

   * 局部变量：方法的参数，或者是方法内部的变量
   * 作用域：一旦超出作用域，立刻从栈内存当中消失

2. 堆(Heap)：凡是new出来的东西，都在堆中。

   * 堆内存里面的东西都有一个地址值：16进制

   * 堆内存里面的数据都有默认值。规则

     如果是整数			默认值为0

     如果是浮点数		默认值为0.0

     如果是字符			默认为‘\u0000’

     如果是布尔值		默认是false

     如果是引用类型	默认为null

3. 方法区(Method Area)：存储.class相关信息，包含方法的信息

4. 本地方法栈(Native Method Stack)：与操作系统相关

5. 寄存器(pc Register)：与CPU相关



#### 什么是类

​	类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该

类事物。

#### 面向对象

​	面向过程：当需要实现一个功能的时候，每一个具体的步骤都要亲力亲为，详细处理每一个细节

​	面向对象：当需要实现一个功能的时候，不关心具体的步骤，而是找一个已经具有该功能的人，来帮我做事

​	对象的特征：封装、继承、多态

​	继承时多态的前提，如果没有继承，就没有多态

​	局部变量：				直接写员变量名

​	本类的成员变量：	 this.成员变量名

​	父类的成员变量：	 super.成员变量名

#### this关键字

1. 通过谁调用方法，谁就是this

#### 字符串

1. 特点
   * 字符串的内容永不可变
   * 正是因为字符串不可改变，所以字符串是可以共享的
   * 字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节

字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中

 对于引用类型来说，==是进行数值的比较

 对于应用类型来说，==是进行地址值的比较

#### static

1. 一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。
2. 如果又了static关键字，那么不需要创建对象，直接就能通过类名称来使用它
3. 无论成员变量，换是成员方法。如果有了static，都推荐使用类名称进行调用
4. 当第一次用到本类时，静态代码块执行唯一的一次
5. 静态内容总是优先于非静态，所以静态代码块比构造方法先执行

静态代码块的典型用途：用来一次性地对静态成员变量进行赋值

**注意：**根据类名称访问静态成员变量的时候，全程和对象没有关系，只和类有关系



#### Arrays

1. abs()获取绝对值
2. ceil()向上取整
3. floor()向下取整
4. round()四舍五入



#### 接口

* Java7接口定义

  * 常量
  * 抽象方法

* Java8

  * 默认方法

    [主要用来解决接口升级的问题]

    [接口的默认方法也可以被接口实现类进行覆盖重写]

    ```java
    public default 返回值类型 方法名称(参数列表){
      方法体;
    }
    ```

  * 静态方法

    ```java
    public static 返回值类型 方法名称(参数列表){
      方法体
    }
    ```

* Java9

  * 私有方法

    普通私有方法，解决多个默认方法之间重复代码问题

    静态私有方法，解决多个静态方法之间重复代码问题

**注意事项:**

1. 接口当中的常量，可以省略public static final,不写默认也是这个
2. 接口当中的常量，必须进行赋值，不能不赋值
3. 接口中常量的名称，使用完全大写的字母，用下划线分割

* 接口没有静态代码块或者构造方法
* 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口
* 如果实现类所实现的多个接口当中，存在抽象方法，那么只需要重写任意一个即可
* 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类
* 如果实现类实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写
* 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先使用父类当中的方法。**【继承优先于接口】**
* 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写【而且带着default关键字】



#### 多态

extends继承或者implements实现，是多态性的前提

一个对象有多种形态

```java
// 代码中体现多态性，其实：父类引用只想子类对象
// 格式
父类名称 对象名 = new 子类名称();
接口名称 对象名 = new 实现类名称();
```

**成员方法**new的是谁就用谁，没有则向上找

**成员变量**左边是谁，优先用谁

* 向上转型一定是安全的，没有问题。但是也有一个缺点。对象一旦向上转型为父类，那么就无法调用子类原本特有的内容

  * 解决方案：用对象的向下转型【还原】instanceof

    ```java
    // 对象 instanceof 类名称
    if(animal instanceof Cat){
      Cat cat = (Cat) animal;
    }
    
    ```

    



​	











