### 常用函数

#### 聚合函数

sum、max、min、avg、count

将一列数据作为一个整体，进行纵向的计算

**注意：**聚合函数的计算，排除null值

* ```sql
  -- 1.包含null的统计
  select count(ifnull(remark,0)) from bus_inport; 
  -- 2.非空的列
  ```

#### 分组查询

**注意：**

* 分组之后查询的字段：分组子段、聚合函数

  ```sql
  select sex,avg(math),count(id) from student groud by sex;
  ```

* where和having的区别

  ```sql
  select sex,avg(math),count(id) from student where math >65 groud by sex having count(id)>2;
  ```

  1. where在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来
  2. where后不可以跟聚合函数，having可以进行聚合函数判断



#### 分页查询

开始的索引 = (当前页码-1)*每页显示条数

MySQL：limit

Oracle：rownum或者rowid



### 约束

* 概念：对表中的数据进行限定，保证数据的正确性，有效性和完整性
* 分类
  1. 主键约束：primary key
  2. 非空约束：not null
  3. 唯一约束：unique
  4. 外键约束：foreign key

#### 数据库的设计

1. 多表之间的关系

   * 一对一
   * 一对多(多对一)
   * 多对多(中间表)

2. 数据库设计的范式

   * 概念：设计数据库时，需要遵循一些规范。需要遵循后边的范式，必须先遵循前边所有的范式要求

     设计数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同规范的要求被称为不同范式，各种范式呈递次规范，越高的范式冗余越小

     目前关系型数据库有六种范式：第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)、第五范式(5NF、完美范式)

   * 分类：

     1. 第一范式:每一列都是不可分割的原子数据项

     2. 第二范式:在1NF基础上，非码属性必须完全依赖与候选码(在1NF基础上消除非主属性对主码部分函数依赖)

        概念

        * 函数依赖：A——>B，如果通过A属性(属性组)的值，可以却低估唯一B属性的值.则称B依赖于A

          例如：学好——>姓名		(学号，课程名)——>分数

        * 完全函数依赖：A——>B，如果A是一个属性组，则B属性值得确认依赖于A属性组中所有的属性值

          例如：(学号，课程名称)——>分数

        * 部分函数依赖：A——>如果A是一个属性组，则B属性值得确定只需要依赖A属性组中某一些值即可

          例如：(学号,课程名称)——>姓名

     3. 第三范式：在2NF基础上，任何非主属性不依赖于其他非主属性(在2NF基础上消除传递依赖)











ƒ